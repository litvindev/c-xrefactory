diff -Naur byacc.1.9/COPYRIGHT byacc-1.9/COPYRIGHT
--- byacc.1.9/COPYRIGHT	1970-01-01 01:00:00.000000000 +0100
+++ byacc-1.9/COPYRIGHT	2006-07-03 12:13:56.000000000 +0200
@@ -0,0 +1,23 @@
+    Berkeley Yacc is an LALR(1) parser generator.  Berkeley Yacc has been made
+as compatible as possible with AT&T Yacc.  Berkeley Yacc can accept any input
+specification that conforms to the AT&T Yacc documentation.  Specifications
+that take advantage of undocumented features of AT&T Yacc will probably be
+rejected.
+
+    Berkeley Yacc is distributed with no warranty whatever.  The code is certain
+to contain errors.  Neither the author nor any contributor takes responsibility
+for any consequences of its use.
+
+    Berkeley Yacc is in the public domain.  The data structures and algorithms
+used in Berkeley Yacc are all either taken from documents available to the
+general public or are inventions of the author.  Anyone may freely distribute
+source or binary forms of Berkeley Yacc whether unchanged or modified.
+Distributers may charge whatever fees they can obtain for Berkeley Yacc.
+Programs generated by Berkeley Yacc may be distributed freely.
+
+    Please report bugs to
+
+			robert.corbett@eng.Sun.COM
+
+Include a small example if possible.  Please include the banner string from
+skeleton.c with the bug report.  Do not expect rapid responses.
diff -Naur byacc.1.9/CSU.diffs byacc-1.9/CSU.diffs
--- byacc.1.9/CSU.diffs	1970-01-01 01:00:00.000000000 +0100
+++ byacc-1.9/CSU.diffs	2006-07-03 12:13:56.000000000 +0200
@@ -0,0 +1,17 @@
+*** main.c.orig	Mon Jul  5 18:47:51 1993
+--- main.c	Mon Jul  5 19:18:46 1993
+***************
+*** 72,76 ****
+  
+  
+! onintr()
+  {
+      done(1);
+--- 72,78 ----
+  
+  
+! void
+! onintr(signo)
+!     int signo;
+  {
+      done(1);
diff -Naur byacc.1.9/debian.control byacc-1.9/debian.control
--- byacc.1.9/debian.control	1970-01-01 01:00:00.000000000 +0100
+++ byacc-1.9/debian.control	2006-07-03 12:13:56.000000000 +0200
@@ -0,0 +1,5 @@
+PACKAGE: byacc
+VERSION: 1.9
+PACKAGE_REVISION: 2
+MAINTAINER: Peter Tobias <tobias@server.et-inf.fho-emden.de>
+DESCRIPTION: The Berkeley LALR parser generator
diff -Naur byacc.1.9/debian.README byacc-1.9/debian.README
--- byacc.1.9/debian.README	1970-01-01 01:00:00.000000000 +0100
+++ byacc-1.9/debian.README	2006-07-03 12:13:56.000000000 +0200
@@ -0,0 +1,8 @@
+Last update: 08/10/94
+
+The following things have been changed for the Debian distribution:
+
+- changed the makefile (CFLAGS)
+
+
+Peter Tobias <tobias@server.et-inf.fho-emden.de>
diff -Naur byacc.1.9/debian.rules byacc-1.9/debian.rules
--- byacc.1.9/debian.rules	1970-01-01 01:00:00.000000000 +0100
+++ byacc-1.9/debian.rules	2006-07-03 12:13:56.000000000 +0200
@@ -0,0 +1,49 @@
+#!/usr/bin/make -f
+
+.PHONY: build
+
+PKG = byacc-1.9
+
+P_REV := $(shell grep "PACKAGE_REVISION:" debian.control | cut -d' ' -f 2)
+
+
+build:
+	make "CFLAGS=-O2 -DNDEBUG" LDFLAGS=-s
+
+install: build
+	install -o root -g root -m 0755 yacc /usr/bin/byacc
+	install -o root -g root -m 0644 yacc.1 /usr/man/man1/byacc.1
+
+clean:
+	make clean
+	rm -f debian-tmp
+
+binary: build
+	install -o root -g root -m 0755 -d debian-tmp
+	install -o root -g root -m 0755 -d debian-tmp/DEBIAN
+	install -o root -g root -m 0755 -d debian-tmp/usr/bin
+	install -o root -g root -m 0755 -d debian-tmp/usr/man/man1
+	install -o root -g root -m 0755 -d debian-tmp/usr/doc/copyright
+	install -o root -g root -m 0755 yacc debian-tmp/usr/bin/byacc
+	install -o root -g root -m 0644 yacc.1 debian-tmp/usr/man/man1/byacc.1
+	install -o root -g root -m 0644 COPYRIGHT debian-tmp/usr/doc/copyright/byacc
+	install -o root -g root -m 0644 debian.control debian-tmp/DEBIAN/control
+	dpkg --build debian-tmp
+	mv debian-tmp.deb ../${PKG}-${P_REV}.deb
+
+source:
+# Makes a source package.
+	chmod +x debian.rules
+	(cd .. && tar cvf ${PKG}-${P_REV}.tar ${PKG} && \
+	 gzip -9v ${PKG}-${P_REV}.tar) || exit 1
+
+diff:
+# Makes a diff package.
+	(cd .. && diff -c -P -r ${PKG}.orig ${PKG} \
+	 > ${PKG}-${P_REV}.debian.diff; [ $$? = 1 ] && \
+	 gzip -9v ${PKG}-${P_REV}.debian.diff) || \
+	 exit 1
+
+dist: source diff binary
+# Make source, diff and binary packages
+
diff -Naur byacc.1.9/main.c byacc-1.9/main.c
--- byacc.1.9/main.c	1993-02-22 07:32:46.000000000 +0100
+++ byacc-1.9/main.c	2006-07-03 12:13:56.000000000 +0200
@@ -71,7 +71,9 @@
 }
 
 
-onintr()
+void
+onintr(signo)
+    int signo;
 {
     done(1);
 }
diff -Naur byacc.1.9/MANIFEST byacc-1.9/MANIFEST
--- byacc.1.9/MANIFEST	1970-01-01 01:00:00.000000000 +0100
+++ byacc-1.9/MANIFEST	2006-07-03 12:13:56.000000000 +0200
@@ -0,0 +1,33 @@
+   File Name		Archive #	Description
+-----------------------------------------------------------
+ ACKNOWLEDGEMENTS           1	
+ CSU.diffs                  1	
+ MANIFEST                   1	This shipping list
+ Makefile                   1	
+ NEW_FEATURES               1	
+ NOTES                      1	
+ NO_WARRANTY                1	
+ README                     1	
+ closure.c                  1	
+ defs.h                     1	
+ error.c                    1	
+ lalr.c                     1	
+ lr0.c                      1	
+ main.c                     1	
+ mkpar.c                    1	
+ output.c                   2	
+ reader.c                   3	
+ skeleton.c                 1	
+ symtab.c                   1	
+ test                       1	
+ test/error.output          1	
+ test/error.tab.c           1	
+ test/error.tab.h           1	
+ test/error.y               1	
+ test/ftp.output            2	
+ test/ftp.tab.c             3	
+ test/ftp.tab.h             1	
+ test/ftp.y                 2	
+ verbose.c                  1	
+ warshall.c                 1	
+ yacc.1                     1	
diff -Naur byacc.1.9/skeleton.c byacc-1.9/skeleton.c
--- byacc.1.9/skeleton.c	1993-02-22 07:53:26.000000000 +0100
+++ byacc-1.9/skeleton.c	2006-07-03 12:13:56.000000000 +0200
@@ -59,16 +59,25 @@
     "#define YYMAXDEPTH 500",
     "#endif",
     "#endif",
+	// [M.V.] 23.1.2001
+	"#ifndef RECURSIVE",
+	//
     "int yydebug;",
     "int yynerrs;",
     "int yyerrflag;",
     "int yychar;",
+    "int lastyystate;",
     "short *yyssp;",
     "YYSTYPE *yyvsp;",
     "YYSTYPE yyval;",
     "YYSTYPE yylval;",
     "short yyss[YYSTACKSIZE];",
     "YYSTYPE yyvs[YYSTACKSIZE];",
+	// [M.V.] 23.1.2001
+	"#else",
+	"#include \"recyacc.h\"",
+	"#endif",
+	//
     "#define yystacksize YYSTACKSIZE",
     0
 };
@@ -80,15 +89,16 @@
     "#define YYREJECT goto yyabort",
     "#define YYACCEPT goto yyaccept",
     "#define YYERROR goto yyerrlab",
+	"#define ERR_RECOVERY_ON 1",
     "int",
     "yyparse()",
     "{",
     "    register int yym, yyn, yystate;",
     "#if YYDEBUG",
     "    register char *yys;",
-    "    extern char *getenv();",
+/*    "    extern char *getenv();", */
     "",
-    "    if (yys = getenv(\"YYDEBUG\"))",
+    "    if ((yys = getenv(\"YYDEBUG\")))",
     "    {",
     "        yyn = *yys;",
     "        if (yyn >= '0' && yyn <= '9')",
@@ -105,9 +115,10 @@
     "    *yyssp = yystate = 0;",
     "",
     "yyloop:",
-    "    if (yyn = yydefred[yystate]) goto yyreduce;",
+    "    if ((yyn = yydefred[yystate])) goto yyreduce;",
     "    if (yychar < 0)",
     "    {",
+	"		 lastyystate = yystate;",
     "        if ((yychar = yylex()) < 0) yychar = 0;",
     "#if YYDEBUG",
     "        if (yydebug)",
@@ -135,6 +146,7 @@
     "        *++yyssp = yystate = yytable[yyn];",
     "        *++yyvsp = yylval;",
     "        yychar = (-1);",
+    "        if (yyerrflag == 1)  yyErrorRecovery();",
     "        if (yyerrflag > 0)  --yyerrflag;",
     "        goto yyloop;",
     "    }",
@@ -156,9 +168,9 @@
     "yyerrlab:",
     "    ++yynerrs;",
     "yyinrecovery:",
-    "    if (yyerrflag < 3)",
+    "    if (yyerrflag < ERR_RECOVERY_ON)",
     "    {",
-    "        yyerrflag = 3;",
+    "        yyerrflag = ERR_RECOVERY_ON;",
     "        for (;;)",
     "        {",
     "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
@@ -241,6 +253,7 @@
     "        *++yyvsp = yyval;",
     "        if (yychar < 0)",
     "        {",
+	"		 	lastyystate = yystate;",
     "            if ((yychar = yylex()) < 0) yychar = 0;",
     "#if YYDEBUG",
     "            if (yydebug)",
diff -Naur byacc.1.9/skeleton.mar byacc-1.9/skeleton.mar
--- byacc.1.9/skeleton.mar	1970-01-01 01:00:00.000000000 +0100
+++ byacc-1.9/skeleton.mar	2006-07-03 12:13:56.000000000 +0200
@@ -0,0 +1,310 @@
+#include "defs.h"
+
+/*  The definition of yysccsid in the banner should be replaced with	*/
+/*  a #pragma ident directive if the target C compiler supports		*/
+/*  #pragma ident directives.						*/
+/*									*/
+/*  If the skeleton is changed, the banner should be changed so that	*/
+/*  the altered version can be easily distinguished from the original.	*/
+/*									*/
+/*  The #defines included with the banner are there because they are	*/
+/*  useful in subsequent code.  The macros #defined in the header or	*/
+/*  the body either are not useful outside of semantic actions or	*/
+/*  are conditional.							*/
+
+char *banner[] =
+{
+    "#ifndef lint",
+    "static char yysccsid[] = \"@(#)yaccpar	1.9 (Berkeley) 02/21/93\";",
+    "#endif",
+    "#define YYBYACC 1",
+    "#define YYMAJOR 1",
+    "#define YYMINOR 9",
+    "#define yyclearin (yychar=(-1))",
+    "#define yyerrok (yyerrflag=0)",
+    "#define YYRECOVERING (yyerrflag!=0)",
+    0
+};
+
+
+char *tables[] =
+{
+    "extern short yylhs[];",
+    "extern short yylen[];",
+    "extern short yydefred[];",
+    "extern short yydgoto[];",
+    "extern short yysindex[];",
+    "extern short yyrindex[];",
+    "extern short yygindex[];",
+    "extern short yytable[];",
+    "extern short yycheck[];",
+    "#if YYDEBUG",
+    "extern char *yyname[];",
+    "extern char *yyrule[];",
+    "#endif",
+    0
+};
+
+
+char *header[] =
+{
+    "#ifdef YYSTACKSIZE",
+    "#undef YYMAXDEPTH",
+    "#define YYMAXDEPTH YYSTACKSIZE",
+    "#else",
+    "#ifdef YYMAXDEPTH",
+    "#define YYSTACKSIZE YYMAXDEPTH",
+    "#else",
+    "#define YYSTACKSIZE 500",
+    "#define YYMAXDEPTH 500",
+    "#endif",
+    "#endif",
+    "int yydebug;",
+    "int yynerrs;",
+    "int yyerrflag;",
+    "int yychar;",
+    "int lastyystate;",
+    "short *yyssp;",
+    "YYSTYPE *yyvsp;",
+    "YYSTYPE yyval;",
+    "YYSTYPE yylval;",
+    "short yyss[YYSTACKSIZE];",
+    "YYSTYPE yyvs[YYSTACKSIZE];",
+    "#define yystacksize YYSTACKSIZE",
+    0
+};
+
+
+char *body[] =
+{
+    "#define YYABORT goto yyabort",
+    "#define YYREJECT goto yyabort",
+    "#define YYACCEPT goto yyaccept",
+    "#define YYERROR goto yyerrlab",
+    "int",
+    "yyparse()",
+    "{",
+    "    register int yym, yyn, yystate;",
+    "#if YYDEBUG",
+    "    register char *yys;",
+/*    "    extern char *getenv();", */
+    "",
+    "    if (yys = getenv(\"YYDEBUG\"))",
+    "    {",
+    "        yyn = *yys;",
+    "        if (yyn >= '0' && yyn <= '9')",
+    "            yydebug = yyn - '0';",
+    "    }",
+    "#endif",
+    "",
+    "    yynerrs = 0;",
+    "    yyerrflag = 0;",
+    "    yychar = (-1);",
+    "",
+    "    yyssp = yyss;",
+    "    yyvsp = yyvs;",
+    "    *yyssp = yystate = 0;",
+    "",
+    "yyloop:",
+    "    if (yyn = yydefred[yystate]) goto yyreduce;",
+    "    if (yychar < 0)",
+    "    {",
+	"		 lastyystate = yystate;",
+    "        if ((yychar = yylex()) < 0) yychar = 0;",
+    "#if YYDEBUG",
+    "        if (yydebug)",
+    "        {",
+    "            yys = 0;",
+    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
+    "            if (!yys) yys = \"illegal-symbol\";",
+    "            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
+    "                    YYPREFIX, yystate, yychar, yys);",
+    "        }",
+    "#endif",
+    "    }",
+    "    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
+    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
+    "    {",
+    "#if YYDEBUG",
+    "        if (yydebug)",
+    "            printf(\"%sdebug: state %d, shifting to state %d\\n\",",
+    "                    YYPREFIX, yystate, yytable[yyn]);",
+    "#endif",
+    "        if (yyssp >= yyss + yystacksize - 1)",
+    "        {",
+    "            goto yyoverflow;",
+    "        }",
+    "        *++yyssp = yystate = yytable[yyn];",
+    "        *++yyvsp = yylval;",
+    "        yychar = (-1);",
+    "        if (yyerrflag == 1)  yyErrorRecovery();",
+    "        if (yyerrflag > 0)  --yyerrflag;",
+    "        goto yyloop;",
+    "    }",
+    "    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
+    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
+    "    {",
+    "        yyn = yytable[yyn];",
+    "        goto yyreduce;",
+    "    }",
+    "    if (yyerrflag) goto yyinrecovery;",
+    "#ifdef lint",
+    "    goto yynewerror;",
+    "#endif",
+    "yynewerror:",
+    "    yyerror(\"syntax error\");",
+    "#ifdef lint",
+    "    goto yyerrlab;",
+    "#endif",
+    "yyerrlab:",
+    "    ++yynerrs;",
+    "yyinrecovery:",
+    "    if (yyerrflag < 1)",
+    "    {",
+    "        yyerrflag = 1;",
+    "        for (;;)",
+    "        {",
+    "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
+    "                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
+    "            {",
+    "#if YYDEBUG",
+    "                if (yydebug)",
+    "                    printf(\"%sdebug: state %d, error recovery shifting\\",
+    " to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);",
+    "#endif",
+    "                if (yyssp >= yyss + yystacksize - 1)",
+    "                {",
+    "                    goto yyoverflow;",
+    "                }",
+    "                *++yyssp = yystate = yytable[yyn];",
+    "                *++yyvsp = yylval;",
+    "                goto yyloop;",
+    "            }",
+    "            else",
+    "            {",
+    "#if YYDEBUG",
+    "                if (yydebug)",
+    "                    printf(\"%sdebug: error recovery discarding state %d\
+\\n\",",
+    "                            YYPREFIX, *yyssp);",
+    "#endif",
+    "                if (yyssp <= yyss) goto yyabort;",
+    "                --yyssp;",
+    "                --yyvsp;",
+    "            }",
+    "        }",
+    "    }",
+    "    else",
+    "    {",
+    "        if (yychar == 0) goto yyabort;",
+    "#if YYDEBUG",
+    "        if (yydebug)",
+    "        {",
+    "            yys = 0;",
+    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
+    "            if (!yys) yys = \"illegal-symbol\";",
+    "            printf(\"%sdebug: state %d, error recovery discards token %d\
+ (%s)\\n\",",
+    "                    YYPREFIX, yystate, yychar, yys);",
+    "        }",
+    "#endif",
+    "        yychar = (-1);",
+    "        goto yyloop;",
+    "    }",
+    "yyreduce:",
+    "#if YYDEBUG",
+    "    if (yydebug)",
+    "        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",
+    "                YYPREFIX, yystate, yyn, yyrule[yyn]);",
+    "#endif",
+    "    yym = yylen[yyn];",
+    "    yyval = yyvsp[1-yym];",
+    "    switch (yyn)",
+    "    {",
+    0
+};
+
+
+char *trailer[] =
+{
+    "    }",
+    "    yyssp -= yym;",
+    "    yystate = *yyssp;",
+    "    yyvsp -= yym;",
+    "    yym = yylhs[yyn];",
+    "    if (yystate == 0 && yym == 0)",
+    "    {",
+    "#if YYDEBUG",
+    "        if (yydebug)",
+    "            printf(\"%sdebug: after reduction, shifting from state 0 to\\",
+    " state %d\\n\", YYPREFIX, YYFINAL);",
+    "#endif",
+    "        yystate = YYFINAL;",
+    "        *++yyssp = YYFINAL;",
+    "        *++yyvsp = yyval;",
+    "        if (yychar < 0)",
+    "        {",
+	"		 	lastyystate = yystate;",
+    "            if ((yychar = yylex()) < 0) yychar = 0;",
+    "#if YYDEBUG",
+    "            if (yydebug)",
+    "            {",
+    "                yys = 0;",
+    "                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
+    "                if (!yys) yys = \"illegal-symbol\";",
+    "                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
+    "                        YYPREFIX, YYFINAL, yychar, yys);",
+    "            }",
+    "#endif",
+    "        }",
+    "        if (yychar == 0) goto yyaccept;",
+    "        goto yyloop;",
+    "    }",
+    "    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
+    "            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
+    "        yystate = yytable[yyn];",
+    "    else",
+    "        yystate = yydgoto[yym];",
+    "#if YYDEBUG",
+    "    if (yydebug)",
+    "        printf(\"%sdebug: after reduction, shifting from state %d \\",
+    "to state %d\\n\", YYPREFIX, *yyssp, yystate);",
+    "#endif",
+    "    if (yyssp >= yyss + yystacksize - 1)",
+    "    {",
+    "        goto yyoverflow;",
+    "    }",
+    "    *++yyssp = yystate;",
+    "    *++yyvsp = yyval;",
+    "    goto yyloop;",
+    "yyoverflow:",
+    "    yyerror(\"yacc stack overflow\");",
+    "yyabort:",
+    "    return (1);",
+    "yyaccept:",
+    "    return (0);",
+    "}",
+    0
+};
+
+
+write_section(section)
+char *section[];
+{
+    register int c;
+    register int i;
+    register char *s;
+    register FILE *f;
+
+    f = code_file;
+    for (i = 0; s = section[i]; ++i)
+    {
+	++outline;
+	while (c = *s)
+	{
+	    putc(c, f);
+	    ++s;
+	}
+	putc('\n', f);
+    }
+}
